/**
 * @license
 * Copyright Â© 2026 Ashraf Morningstar
 * https://github.com/AshrafMorningstar
 * 
 * Licensed under the MIT License.
 * This is a personal educational recreation.
 * Original concepts remain property of their respective creators.
 * 
 * @author Ashraf Morningstar
 * @see https://github.com/AshrafMorningstar
 */
import { Octokit } from "octokit";
import { GitEvent, UserConfig } from "../types";

let octokit: Octokit | null = null;
let owner = "";
let repo = "";
let defaultBranchSha = "";

// Helper to sanitize filenames
const sanitizeFilename = (title: string) => {
  return title.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') + '.md';
};

export const initGitHub = async (token: string, repoName: string, userName: string) => {
  try {
    octokit = new Octokit({ auth: token });
    owner = userName;
    repo = repoName;
    
    // 1. Check Repo existence and Permissions
    const { data: repoData } = await octokit.rest.repos.get({ owner, repo });
    
    if (!repoData.permissions?.push) {
      throw new Error(`Token exists but lacks WRITE/PUSH access to ${owner}/${repo}. Check token scopes.`);
    }

    // 2. Get Default Branch SHA
    try {
        const { data: refData } = await octokit.rest.git.getRef({
            owner,
            repo,
            ref: `heads/${repoData.default_branch}`,
        });
        defaultBranchSha = refData.object.sha;
    } catch (e) {
        // Handle Empty Repo or Branch missing (409 or 404)
        console.log("Repository appears empty or default branch missing. Attempting initialization...");
        
        try {
             // Create a README to initialize the repo
             const { data: contentData } = await octokit.rest.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: 'README.md',
                message: 'Initial commit by GitHub History Weaver',
                content: btoa(`# ${repo}\n\nGenerated by GitHub History Weaver. History starts here.`),
                committer: {
                    name: owner,
                    email: `${owner}@users.noreply.github.com`
                },
                author: {
                    name: owner,
                    email: `${owner}@users.noreply.github.com`
                }
             });
             
             if (contentData.commit && contentData.commit.sha) {
                 defaultBranchSha = contentData.commit.sha;
             } else {
                 throw new Error("Created README but got no commit SHA.");
             }
        } catch (initErr: any) {
            throw new Error(`Could not initialize empty repository: ${initErr.message}`);
        }
    }
    
    return true;
  } catch (error: any) {
    console.error("GitHub Init Error:", error);
    throw new Error(error.message || "Failed to connect to GitHub. Check token permissions and repo existence.");
  }
};

export const executeGitEvent = async (event: GitEvent, config: UserConfig): Promise<string> => {
  if (!octokit) throw new Error("GitHub service not initialized");

  switch (event.type) {
    case 'commit':
      return await handleCommit(event);
    case 'branch':
      return await handleCreateBranch(event);
    case 'merge':
      return await handleMerge(event);
    case 'issue':
      return await handleCreateIssue(event);
    case 'pr':
      return await handleCreatePR(event);
    case 'tag':
      return await handleCreateTag(event);
    default:
      return `Skipped event type: ${event.type}`;
  }
};

const handleCommit = async (event: GitEvent) => {
  if (!octokit) throw new Error("No octokit instance");
  
  const branchName = event.branch || 'main';
  
  // 1. Get the current head SHA of the branch
  // Robustness Fix: If branch doesn't exist, we fall back to defaultBranchSha
  let branchSha = defaultBranchSha;
  try {
    const { data: refData } = await octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${branchName}`,
    });
    branchSha = refData.object.sha;
  } catch (e) {
    // Branch doesn't exist. We'll use defaultBranchSha as base, 
    // effectively branching off main if the user forgot to list a branch event.
  }

  // 2. Get the Tree of the current commit
  let baseTreeSha;
  try {
    const { data: commitData } = await octokit.rest.git.getCommit({
        owner,
        repo,
        commit_sha: branchSha,
    });
    baseTreeSha = commitData.tree.sha;
  } catch (e) {
     throw new Error(`Could not fetch base tree for ${branchSha}. Repo might be in weird state.`);
  }

  // 3. Create a Blob (File Content)
  // We add 'src/' to keep root clean, and randomize filename to prevent collisions in simulated history
  const fileName = `src/${sanitizeFilename(event.title)}`;
  const content = `# ${event.title}\n\n${event.description}\n\nDate: ${event.date}\nAuthor: ${event.author}`;
  
  const { data: blobData } = await octokit.rest.git.createBlob({
    owner,
    repo,
    content: content,
    encoding: 'utf-8',
  });

  // 4. Create a Tree
  const { data: treeData } = await octokit.rest.git.createTree({
    owner,
    repo,
    base_tree: baseTreeSha,
    tree: [
      {
        path: fileName,
        mode: '100644',
        type: 'blob',
        sha: blobData.sha,
      },
      // We overwrite a LOG file to ensure strict linearity if needed, or just to show activity
      {
        path: 'HISTORY_LOG.md',
        mode: '100644',
        type: 'blob',
        content: `Last Update: ${event.date} - ${event.title}` 
      }
    ],
  });

  // 5. Create the Commit with Backdated Time
  const { data: newCommitData } = await octokit.rest.git.createCommit({
    owner,
    repo,
    message: event.title,
    tree: treeData.sha,
    parents: [branchSha],
    author: {
      name: owner,
      email: `${owner}@users.noreply.github.com`,
      date: event.date, // Backdating magic
    },
    committer: {
      name: owner,
      email: `${owner}@users.noreply.github.com`,
      date: event.date,
    }
  });

  // 6. Update the Reference
  // Robustness Fix: If updateRef fails (e.g., branch didn't exist), try createRef
  try {
    await octokit.rest.git.updateRef({
        owner,
        repo,
        ref: `heads/${branchName}`,
        sha: newCommitData.sha,
        force: true // Force update is risky but necessary for history weaving
    });
  } catch (e) {
    try {
        await octokit.rest.git.createRef({
            owner,
            repo,
            ref: `refs/heads/${branchName}`,
            sha: newCommitData.sha
        });
    } catch (createErr: any) {
        throw new Error(`Failed to update or create branch ${branchName}: ${createErr.message}`);
    }
  }

  // Update tracking if we just moved main
  if (branchName === 'main' || branchName === 'master') {
    defaultBranchSha = newCommitData.sha;
  }

  return `Committed to ${branchName}: ${event.title}`;
};

const handleCreateBranch = async (event: GitEvent) => {
  if (!octokit) throw new Error("No octokit instance");
  if (!event.branch) return "Skipped branch creation (no name)";

  try {
    await octokit.rest.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${event.branch}`,
      sha: defaultBranchSha,
    });
    return `Created Branch: ${event.branch}`;
  } catch (e: any) {
    if (e.status === 422) return `Branch ${event.branch} already exists (Skipped)`;
    throw e;
  }
};

const handleMerge = async (event: GitEvent) => {
  if (!octokit) throw new Error("No octokit instance");
  
  const sourceBranch = event.branch || 'feature';
  const targetBranch = 'main'; // Simplification for demo

  // We perform a low-level merge to preserve backdating.
  // 1. Get SHA of target (main)
  const { data: targetRef } = await octokit.rest.git.getRef({ owner, repo, ref: `heads/${targetBranch}` });
  const targetSha = targetRef.object.sha;

  // 2. Get SHA of source (feature)
  let sourceSha;
  try {
    const { data: sourceRef } = await octokit.rest.git.getRef({ owner, repo, ref: `heads/${sourceBranch}` });
    sourceSha = sourceRef.object.sha;
  } catch (e) {
    return `Merge skipped: Source branch ${sourceBranch} not found.`;
  }

  // 3. Get Source Tree (We simulate the merge result being the feature state)
  const { data: sourceCommit } = await octokit.rest.git.getCommit({ owner, repo, commit_sha: sourceSha });
  const treeSha = sourceCommit.tree.sha;

  // 4. Create Merge Commit
  const { data: mergeCommit } = await octokit.rest.git.createCommit({
    owner,
    repo,
    message: event.title || `Merge branch '${sourceBranch}'`,
    tree: treeSha,
    parents: [targetSha, sourceSha], // Double parent makes it a merge
    author: {
        name: owner,
        email: `${owner}@users.noreply.github.com`,
        date: event.date,
    },
    committer: {
        name: owner,
        email: `${owner}@users.noreply.github.com`,
        date: event.date,
    }
  });

  // 5. Update Target Branch
  await octokit.rest.git.updateRef({
    owner,
    repo,
    ref: `heads/${targetBranch}`,
    sha: mergeCommit.sha,
  });

  if (targetBranch === 'main' || targetBranch === 'master') {
    defaultBranchSha = mergeCommit.sha;
  }

  return `Merged ${sourceBranch} into ${targetBranch}`;
};

const handleCreateIssue = async (event: GitEvent) => {
  if (!octokit) throw new Error("No octokit instance");

  const { data } = await octokit.rest.issues.create({
    owner,
    repo,
    title: event.title,
    body: event.description,
    labels: event.tags,
  });

  return `Created Issue #${data.number}: ${event.title}`;
};

const handleCreatePR = async (event: GitEvent) => {
  if (!octokit) throw new Error("No octokit instance");

  const headBranch = event.branch || 'feature-branch';
  
  try {
    const { data } = await octokit.rest.pulls.create({
      owner,
      repo,
      title: event.title,
      body: event.description,
      head: headBranch,
      base: 'main',
    });
    return `Created PR #${data.number} (${headBranch} -> main)`;
  } catch (e: any) {
    // 422 often means PR already exists or no commits difference
    if (e.status === 422 && e.message.includes('A pull request already exists')) {
        return `PR for ${headBranch} already exists (Skipped)`;
    }
    return `PR Creation Skipped: ${e.message}`; 
  }
};

const handleCreateTag = async (event: GitEvent) => {
    if (!octokit) throw new Error("No octokit instance");

    // Tag the current default branch (main)
    try {
        await octokit.rest.git.createRef({
            owner,
            repo,
            ref: `refs/tags/${event.title.replace(/ /g, '_')}`, // Sanitize tag name
            sha: defaultBranchSha
        });
        return `Created Tag: ${event.title}`;
    } catch (e: any) {
        return `Tag Creation Failed: ${e.message}`;
    }
}